default:
  tags:
    - bigdata
    - dmz
    - docker

stages:
  - build test image
  - static analysis
  - tests
  - post tests
  - artifacts
  - deploy

include:
  # VAULT
  - project: DevOps/cicd-store/gitlabci/vault
    ref: v5
    file:
      - .base_vault_get_field.yml

  # DOCKER
  - project: DevOps/cicd-store/gitlabci/docker
    ref: v8
    file:
      - .base_docker_build.yml
      - .base_docker_cleaner.yml

  # ARTIFACTORY
  - project: DevOps/cicd-store/gitlabci/artifactory
    ref: v4
    file:
      - .base_rt_upload.yml
      - .base_rt_cli.yml

  # PAGES
  - project: DevOps/cicd-store/gitlabci/pages
    ref: v2
    file: .base_pages_deploy_sphinx.yml

  # PIP BUILD AND DEPLOY TO JFROG
  - project: DevOps/cicd-store/gitlabci/python
    ref: v4
    file:
      - .base_pip_poetry_pkg_build_and_deploy_to_jfrog.yml

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: never

    - if: $CI_COMMIT_BRANCH =~ /^(master|main)$/
      when: never

    - when: always

variables:
  DEFAULT_PYTHON: '3.11'
  DEFAULT_PYDANTIC: '2'
  IMAGE_PREFIX: ${HARBOR_HOST}/${HARBOR_PROJECT}/${CI_PROJECT_PATH}/test/backend

### --------------- Get Vault secret --------------- ###
devops_get_techuser_secrets:
  extends: .base_vault_get_field
  variables:
    VAULT_ROLE_ID: $DEVOPS_VAULT_ROLE_ID
    VAULT_SECRET_ID: $DEVOPS_VAULT_SECRET_ID
    VAULT_PATH: platform/onetools/$CICD_USER_NAME
    VAULT_FIELD: password
    VARIABLE_NAME: CICD_USER_PASSWORD
  interruptible: true

### --------------- Build docker images --------------- ###
backend_test_image:
  extends: .base_docker_build
  stage: build test image
  parallel:
    matrix:
      - PYTHON_VERSION: ['3.7', '3.11']
        PYDANTIC_VERSION: ['1', '2']
  variables:
    CICD_DOCKER__FILE_PATH: ./docker/Dockerfile.test
    CICD_DOCKER__IMAGE_NAME: ${HARBOR_HOST}/${HARBOR_PROJECT}/${CI_PROJECT_PATH}/test/backend/python${PYTHON_VERSION}/pydantic${PYDANTIC_VERSION}
    CICD_DOCKER__CACHE_FROM: ${HARBOR_HOST}/${HARBOR_PROJECT}/${CI_PROJECT_PATH}/test/backend/python${PYTHON_VERSION}/pydantic${PYDANTIC_VERSION}:develop
    CICD_DOCKER__IMAGE_TAG: ${CI_COMMIT_REF_SLUG}
    CICD_DOCKER__BUILD_EXTRA_ARGS: --build-arg PYTHON_VERSION=$PYTHON_VERSION --build-arg PYDANTIC_VERSION=${PYDANTIC_VERSION}
    CICD_DOCKER__STOP_IF_EXISTS: 'false'
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - when: on_success
  interruptible: true

backend_ldap_test_image:
  extends: .base_docker_build
  stage: build test image
  variables:
    CICD_DOCKER__FILE_PATH: ./docker/Dockerfile.ldap
    CICD_DOCKER__IMAGE_NAME: ${HARBOR_HOST}/${HARBOR_PROJECT}/${CI_PROJECT_PATH}/test/ldap
    CICD_DOCKER__CACHE_FROM: ${HARBOR_HOST}/${HARBOR_PROJECT}/${CI_PROJECT_PATH}/test/ldap:develop
    CICD_DOCKER__IMAGE_TAG: ${CI_COMMIT_REF_SLUG}
    CICD_DOCKER__STOP_IF_EXISTS: 'false'
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - when: on_success
  interruptible: true

build_backend_image:
  extends: .base_docker_build
  stage: build test image
  variables:
    CICD_DOCKER__FILE_PATH: ./docker/Dockerfile.backend
    CICD_DOCKER__IMAGE_NAME: ${HARBOR_HOST}/${HARBOR_PROJECT}/${CI_PROJECT_PATH}/backend
    CICD_DOCKER__CACHE_FROM: ${HARBOR_HOST}/${HARBOR_PROJECT}/${CI_PROJECT_PATH}/backend:develop
    CICD_DOCKER__IMAGE_TAG: ${CI_COMMIT_REF_SLUG}
    CICD_DOCKER__BUILD_EXTRA_ARGS: --target=prod
    CICD_DOCKER__STOP_IF_EXISTS: 'false'
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^(dev|develop)$/
      variables:
        CICD_DOCKER__IMAGE_TAG: develop
    - if: $CI_COMMIT_TAG
      variables:
        CICD_DOCKER__ADDITIONAL_TAGS: latest
        CICD_DOCKER__IMAGE_TAG: ${CI_COMMIT_TAG}
    - when: on_success
  interruptible: true

get_version:
  image: ${IMAGE_PREFIX}/python${DEFAULT_PYTHON}/pydantic${DEFAULT_PYDANTIC}:${CI_COMMIT_REF_SLUG}
  stage: static analysis
  script:
    - >
      if [[ "x$CI_COMMIT_TAG" != "x" ]]; then
        # read release number from git tag
        echo "RELEASE=$CI_COMMIT_TAG" >> deploy.env;
        echo "VERSION=$CI_COMMIT_TAG" >> deploy.env;
      else
        # read release number from pyproject.toml
        export "RELEASE=$(poetry version -s)";
        echo "RELEASE=$RELEASE" >> deploy.env

        if [[ "x$CI_COMMIT_BRANCH" != "xdevelop" ]] && [[ "x$CI_COMMIT_BRANCH" != "xdev" ]]; then
          # feature/bugfix branch - version format is 1.2.3.dev456+feature.789
          branch=$(echo "$CI_COMMIT_REF_SLUG" | tr '-' '.');
          export VERSION="$RELEASE.dev${CI_PIPELINE_IID}+${branch}";
        else
          # dev/develop branch - version format is 1.2.3.dev456
          export VERSION="$RELEASE.dev${CI_PIPELINE_IID}";
        fi
        echo "VERSION=$VERSION" >> deploy.env
      fi
  artifacts:
    reports:
      dotenv: deploy.env
  rules:
    - if: $CI_COMMIT_TAG
      variables:
        DOCKER_IMAGE_TAG: develop
      when: on_success
    - when: on_success
  interruptible: true

mypy:
  image: ${IMAGE_PREFIX}/python${DEFAULT_PYTHON}/pydantic${DEFAULT_PYDANTIC}:${CI_COMMIT_REF_SLUG}
  stage: static analysis
  script:
    - python -m mypy ./horizon --config-file ./pyproject.toml
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - when: on_success
  interruptible: true

flake8:
  image: ${IMAGE_PREFIX}/python${DEFAULT_PYTHON}/pydantic${DEFAULT_PYDANTIC}:${CI_COMMIT_REF_SLUG}
  stage: static analysis
  script:
    - python -m flake8 --max-line-length 120 --format=default ./horizon 2>&1 | tee flake8.txt
  artifacts:
    when: always
    paths: [flake8.txt]
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - when: on_success
  interruptible: true

black:
  image: ${IMAGE_PREFIX}/python${DEFAULT_PYTHON}/pydantic${DEFAULT_PYDANTIC}:${CI_COMMIT_REF_SLUG}
  stage: static analysis
  script:
    - python -m black ./horizon --check
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - when: on_success
  interruptible: true

bandit:
  image: ${IMAGE_PREFIX}/python${DEFAULT_PYTHON}/pydantic${DEFAULT_PYDANTIC}:${CI_COMMIT_REF_SLUG}
  stage: static analysis
  script:
    - python -m bandit -ll -iii -r ./horizon -f json -o ./bandit.json
  artifacts:
    when: always
    paths: [./bandit.json]
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - when: on_success
  interruptible: true

test-backend:
  image: ${IMAGE_PREFIX}/python${PYTHON_VERSION}/pydantic${PYDANTIC_VERSION}:${CI_COMMIT_REF_SLUG}
  stage: tests
  parallel:
    matrix:
      - PYTHON_VERSION: ['3.7', '3.11']
        PYDANTIC_VERSION: ['1', '2']
  variables:
    HORIZON__DATABASE__URL: postgresql+asyncpg://horizon:Aeviphai6juo3ooY7iecaivieX5OoMai@db:5432/horizon
    HORIZON__AUTH__ACCESS_TOKEN__SECRET_KEY: bae1thahr8Iyaisai0kohvoh1aeg5quu
    HORIZON__AUTH__LDAP__URL: ldap://ldap:389
    HORIZON__AUTH__LDAP__BASE_DN: ou=people,dc=ldapmock,dc=local
    HORIZON__SERVER__DEBUG: 'true'
    HORIZON__SERVER__LOGGING__PRESET: colored
  services:
    - name: central-mirror.services.mts.ru/postgres:15-alpine
      alias: db
      variables:
        POSTGRES_DB: horizon
        POSTGRES_USER: horizon
        POSTGRES_PASSWORD: Aeviphai6juo3ooY7iecaivieX5OoMai
    - name: ${HARBOR_HOST}/${HARBOR_PROJECT}/${CI_PROJECT_PATH}/test/ldap:${CI_COMMIT_REF_SLUG}
      alias: ldap
  script:
    - ./docker/wait-for-it.sh -h db -p 5432 -t 60
    - python -m horizon.backend.db.migrations upgrade head
    - python -m coverage run -m pytest -v -s -k "not client" --junitxml=reports/junit-backend.xml
  artifacts:
    when: always
    paths:
      - ${CI_PROJECT_DIR}/reports
    reports:
      junit:
        - ${CI_PROJECT_DIR}/reports/*.xml
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - when: on_success
  interruptible: true

test-client:
  image: ${IMAGE_PREFIX}/python${PYTHON_VERSION}/pydantic${PYDANTIC_VERSION}:${CI_COMMIT_REF_SLUG}
  stage: tests
  parallel:
    matrix:
      - PYTHON_VERSION: ['3.7', '3.11']
        PYDANTIC_VERSION: ['1', '2']
  variables:
    HORIZON__DATABASE__URL: postgresql+asyncpg://horizon:Aeviphai6juo3ooY7iecaivieX5OoMai@db:5432/horizon
    HORIZON__AUTH__ACCESS_TOKEN__SECRET_KEY: bae1thahr8Iyaisai0kohvoh1aeg5quu
    HORIZON__SERVER__DEBUG: 'true'
    HORIZON__SERVER__LOGGING__PRESET: colored
    HORIZON_TEST_SERVER_URL: http://backend:8000
    # Enables creation of a Docker network per build with the docker executor
    FF_NETWORK_PER_BUILD: 1
  services:
    - name: central-mirror.services.mts.ru/postgres:15-alpine
      alias: db
      variables:
        POSTGRES_DB: horizon
        POSTGRES_USER: horizon
        POSTGRES_PASSWORD: Aeviphai6juo3ooY7iecaivieX5OoMai
    - name: ${HARBOR_HOST}/${HARBOR_PROJECT}/${CI_PROJECT_PATH}/backend:${CI_COMMIT_REF_SLUG}
      alias: backend
  script:
    - ./docker/wait-for-it.sh -h db -p 5432 -t 60
    - ./docker/wait-for-it.sh -h backend -p 8000 -t 60
    - python -m horizon.backend.db.migrations upgrade head
    - python -m coverage run -m pytest -k 'client' -v -s --junitxml=reports/junit-client-${PYTHON_VERSION}.xml
  artifacts:
    when: always
    paths:
      - ${CI_PROJECT_DIR}/reports
    reports:
      junit:
        - ${CI_PROJECT_DIR}/reports/junit*.xml
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - when: on_success
  interruptible: true

coverage:
  image: ${IMAGE_PREFIX}/python${DEFAULT_PYTHON}/pydantic${DEFAULT_PYDANTIC}:${CI_COMMIT_REF_SLUG}
  stage: post tests
  dependencies:
    - test-backend
    - test-client
  script:
    - python -m coverage combine
    - python -m coverage xml -o ./reports/coverage.xml -i
    - python -m coverage html -d ./reports/coverage.html -i
    - python -m coverage report -i
  coverage: /TOTAL.*?(\d+\.?\d+)?%/
  artifacts:
    when: always
    paths:
      - ${CI_PROJECT_DIR}/reports/
    reports:
      coverage_report:
        coverage_format: cobertura
        path: ${CI_PROJECT_DIR}/reports/coverage.xml
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - when: on_success
  interruptible: true

### --------------- Build and publish docs --------------- ###
build_docs:
  image: ${IMAGE_PREFIX}/python${DEFAULT_PYTHON}/pydantic${DEFAULT_PYDANTIC}:${DOCKER_IMAGE_TAG}
  stage: post tests
  dependencies:
    - get_version
  variables:
    DOCKER_IMAGE_TAG: ${CI_COMMIT_REF_SLUG}
    BACKEND_IMAGE_TAG: ${CI_COMMIT_REF_SLUG}
    HORIZON__DATABASE__URL: postgresql+asyncpg://horizon:Aeviphai6juo3ooY7iecaivieX5OoMai@db:5432/horizon
    HORIZON__AUTH__ACCESS_TOKEN__SECRET_KEY: bae1thahr8Iyaisai0kohvoh1aeg5quu
    HORIZON__SERVER__DEBUG: 'true'
    HORIZON__SERVER__LOGGING__PRESET: colored
    # Enables creation of a Docker network per build with the docker executor
    FF_NETWORK_PER_BUILD: 1
  services:
    - name: central-mirror.services.mts.ru/postgres:15-alpine
      alias: db
      variables:
        POSTGRES_DB: horizon
        POSTGRES_USER: horizon
        POSTGRES_PASSWORD: Aeviphai6juo3ooY7iecaivieX5OoMai
    - name: ${HARBOR_HOST}/${HARBOR_PROJECT}/${CI_PROJECT_PATH}/backend:${BACKEND_IMAGE_TAG}
      alias: backend
  before_script:
    # update version number in docs
    - poetry version "${VERSION}"
    # get openapi.json
    - wget http://backend:8000/openapi.json -O docs/static/openapi.json
  script:
    - cd docs
    - make html
    - tar cvzf html-${VERSION}.tar.gz -C _build/html .
    - >
      if [ "$CI_COMMIT_TAG" != "" ]; then
        cp html-${VERSION}.tar.gz html-latest.tar.gz;
      fi
  artifacts:
    paths:
      - docs/html-*.tar.gz
    reports:
      dotenv: deploy.env
  rules:
    - if: $CI_COMMIT_TAG
      variables:
        DOCKER_IMAGE_TAG: develop
        BACKEND_IMAGE_TAG: $CI_COMMIT_TAG
      when: on_success
    - when: on_success
  interruptible: true

publish_docs:
  extends: .base_rt_upload
  stage: artifacts
  variables:
    CICD_ARTIFACTORY__URL: https://artifactory.mts.ru/artifactory
    CICD_ARTIFACTORY__USER: $CICD_USER_NAME
    CICD_ARTIFACTORY__PASSWORD: $CICD_USER_PASSWORD
    CICD_ARTIFACTORY__ARTIFACTS_PATTERN: docs/html-*.tar.gz
    CICD_ARTIFACTORY__UPLOAD_PATH: docs-onetl-generic-local/${CI_PROJECT_NAME}/
  dependencies:
    - build_docs
    - devops_get_techuser_secrets
  interruptible: true

## --------------- DEPLOY --------------- ###
pip:
  extends: .base_pip_poetry_pkg_build_and_deploy_to_jfrog
  image: ${IMAGE_PREFIX}/python${DEFAULT_PYTHON}/pydantic${DEFAULT_PYDANTIC}:${DOCKER_IMAGE_TAG}
  stage: artifacts
  dependencies:
    - devops_get_techuser_secrets
    - get_version
  variables:
    DOCKER_IMAGE_TAG: ${CI_COMMIT_REF_SLUG}
    CICD_PYTHON__REPO_URL: https://artifactory.mts.ru/artifactory/api/pypi/own-onetl-pypi-local/
    CICD_PYTHON__REPO_USER: $CICD_USER_NAME
    CICD_PYTHON__REPO_PASSWORD: $CICD_USER_PASSWORD
  before_script:
    # update version number in pyproject.toml and package sources
    - poetry version "${VERSION}"
  rules:
    - if: $CI_COMMIT_TAG
      variables:
        DOCKER_IMAGE_TAG: develop
      when: on_success
    - when: on_success
  interruptible: true

remove_dev_versions:
  extends: .base_rt_cli
  stage: artifacts
  dependencies:
    - devops_get_techuser_secrets
  variables:
    CICD_ARTIFACTORY__URL: https://artifactory.mts.ru/artifactory
    CICD_ARTIFACTORY__USER: $CICD_USER_NAME
    CICD_ARTIFACTORY__PASSWORD: $CICD_USER_PASSWORD
  script:
  # Remove artifacts for feature/bug branch
    - export CI_COMMIT_REF_SLUG=$(echo $CI_COMMIT_REF_SLUG | tr '-' '.')
    - jf rt delete docs-onetl-generic-local/${CI_PROJECT_NAME}/docs/html-${CI_COMMIT_TAG}.dev*
    - jf rt delete own-onetl-pypi-local/${CI_PROJECT_NAME}/${CI_COMMIT_TAG}.dev*
  rules:
  # run only if release
    - if: $CI_COMMIT_TAG
      when: on_success
    - when: never
  allow_failure: true

pages:
  extends: .base_pages_deploy_sphinx
  stage: deploy
  variables:
    CICD_PAGES__ARTIFACTORY_USER: $CICD_USER_NAME
    CICD_PAGES__ARTIFACTORY_PASSWORD: $CICD_USER_PASSWORD
    CICD_PAGES__ARTIFACTORY_DOCS_PATH: docs-onetl-generic-local/${CI_PROJECT_NAME}/docs
  interruptible: true

## --------------- Remove artifacts after remove feature/bug branch --------------- ###
init_docs:
  stage: .post
  dependencies:
    - get_version
  environment:
    name: docs/$CI_COMMIT_REF_SLUG
    url: ${CI_PAGES_URL}/${VERSION}/
    on_stop: cleanup_docs
  script:
    - echo "Start review"
  rules:
  # environment is used to remove artifacts build in feature/ and bugfix/ branches only
  # dev and release packages are left intact
    - if: $CI_COMMIT_BRANCH =~ /^(dev|develop)$/
      when: never
    - if: $CI_COMMIT_TAG
      when: never
    - when: on_success

cleanup_docs:
  extends: .base_rt_cli
  stage: .post
  dependencies:
    - devops_get_techuser_secrets
  variables:
    CICD_ARTIFACTORY__URL: https://artifactory.mts.ru/artifactory
    CICD_ARTIFACTORY__USER: $CICD_USER_NAME
    CICD_ARTIFACTORY__PASSWORD: $CICD_USER_PASSWORD
  script:
  # Remove artifacts for feature/bug branch
    - export CI_COMMIT_REF_SLUG=$(echo $CI_COMMIT_REF_SLUG | tr '-' '.')
    - jf rt delete docs-onetl-generic-local/${CI_PROJECT_NAME}/docs/*+${CI_COMMIT_REF_SLUG}*
    - jf rt delete own-onetl-pypi-local/${CI_PROJECT_NAME}/*+${CI_COMMIT_REF_SLUG}
  environment:
    name: docs/$CI_COMMIT_REF_SLUG
    action: stop
  rules:
  # environment is used to remove artifacts build in feature/ and bugfix/ branches only
  # dev and release packages are left intact
    - if: $CI_COMMIT_BRANCH =~ /^(dev|develop)$/
      when: never
    - if: $CI_COMMIT_TAG
      when: never
    - when: manual
      allow_failure: true

docs_develop:
  stage: .post
  dependencies:
    - get_version
  environment:
    name: docs/develop
    url: ${CI_PAGES_URL}/${VERSION}/
  script:
    - echo "Start review"
  rules:
  # environment is used to show link to documentation build for development branch
    - if: $CI_COMMIT_BRANCH =~ /^(dev|develop)$/
      when: on_success
    - when: never

init_docker:
  stage: .post
  environment:
    name: docker/$CI_COMMIT_REF_SLUG
    on_stop: cleanup_docker
  script:
    - echo "Start review"
  rules:
  # environment is used to remove artifacts build in feature/ and bugfix/ branches only
  # dev and release packages are left intact
    - if: $CI_COMMIT_BRANCH =~ /^(dev|develop)$/
      when: never
    - if: $CI_COMMIT_TAG
      when: never
    - when: on_success

cleanup_docker:
  extends: .base_docker_cleaner
  stage: .post
  dependencies: []
  variables:
    CICD_DOCKER__IMAGE_TAGS: ${CI_COMMIT_REF_SLUG}
  script:
    - !reference [.base_tools__bricks_send_usage_statistics, script]
    - !reference [.base_docker_cleaner__bricks_debug, script]
    - CICD_DOCKER__IMAGE_NAME=${HARBOR_PROJECT}/${CI_PROJECT_PATH}/test/backend/python3.7/pydantic1
    - !reference [.base_docker_cleaner__bricks_remove_tags, script]
    - CICD_DOCKER__IMAGE_NAME=${HARBOR_PROJECT}/${CI_PROJECT_PATH}/test/backend/python3.11/pydantic1
    - !reference [.base_docker_cleaner__bricks_remove_tags, script]
    - CICD_DOCKER__IMAGE_NAME=${HARBOR_PROJECT}/${CI_PROJECT_PATH}/test/backend/python3.7/pydantic2
    - !reference [.base_docker_cleaner__bricks_remove_tags, script]
    - CICD_DOCKER__IMAGE_NAME=${HARBOR_PROJECT}/${CI_PROJECT_PATH}/test/backend/python3.11/pydantic2
    - !reference [.base_docker_cleaner__bricks_remove_tags, script]
    - CICD_DOCKER__IMAGE_NAME=${HARBOR_PROJECT}/${CI_PROJECT_PATH}/test/ldap
    - !reference [.base_docker_cleaner__bricks_remove_tags, script]
    - CICD_DOCKER__IMAGE_NAME=${HARBOR_PROJECT}/${CI_PROJECT_PATH}/backend
    - !reference [.base_docker_cleaner__bricks_remove_tags, script]
  environment:
    name: docker/$CI_COMMIT_REF_SLUG
    action: stop
  rules:
  # environment is used to remove artifacts build in feature/ and bugfix/ branches only
  # dev and release packages are left intact
    - if: $CI_COMMIT_BRANCH =~ /^(dev|develop)$/
      when: never
    - if: $CI_COMMIT_TAG
      when: never
    - when: manual
      allow_failure: true
